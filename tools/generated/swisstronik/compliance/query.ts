// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.28.0
// source: swisstronik/compliance/query.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import {
  AddressDetails,
  IssuerDetails,
  OperatorDetails,
  Verification,
  VerificationDetails,
  VerificationType,
  verificationTypeFromJSON,
  verificationTypeToJSON,
} from "./entities";
import { Params } from "./params";

export const protobufPackage = "swisstronik.compliance";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params?: Params | undefined;
}

/** QueryOperatorDetailsRequest is request type for Query/OperatorDetails RPC method. */
export interface QueryOperatorDetailsRequest {
  operatorAddress: string;
}

/** QueryOperatorDetailsResponse is response type for Query/OperatorDetails RPC method. */
export interface QueryOperatorDetailsResponse {
  details?: OperatorDetails | undefined;
}

/** QueryAddressDetailsRequest is request type for the Query/AddressDetails RPC method. */
export interface QueryAddressDetailsRequest {
  address: string;
}

/** QueryAddressDetailsResponse is response type for the Query/AddressDetails RPC method. */
export interface QueryAddressDetailsResponse {
  /** data holds all the verification data for provided address */
  data?: AddressDetails | undefined;
}

/** QueryAddressesDetailsRequest is request type for the Query/AddressesDetails RPC method. */
export interface QueryAddressesDetailsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryAddressesDetailsResponse is response type for the Query/AddressesDetails RPC method. */
export interface QueryAddressesDetailsResponse {
  /** addresses is a slice of registered addresses for the compliance module */
  addresses: QueryAddressesDetailsResponse_MergedAddressDetails[];
  /** pagination defines the pagination in the response. */
  pagination?: PageResponse | undefined;
}

/**
 * MergedAddressDetails is merged structure of iterating key and `AddressDetails` in `entities.proto`.
 * `address` is an iterating key, and the following items should be same with `AddressDetails`.
 */
export interface QueryAddressesDetailsResponse_MergedAddressDetails {
  address: string;
  isVerified: boolean;
  isRevoked: boolean;
  verifications: Verification[];
}

/** QueryIssuerDetailsRequest is request type for the Query/IssuerDetails RPC method. */
export interface QueryIssuerDetailsRequest {
  issuerAddress: string;
}

/** QueryIssuerDetailsResponse is response type for the Query/IssuerDetails RPC method. */
export interface QueryIssuerDetailsResponse {
  details?: IssuerDetails | undefined;
}

/** QueryIssuersDetailsRequest is request type for the Query/IssuersDetails RPC method. */
export interface QueryIssuersDetailsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryIssuersDetailsResponse is response type for the Query/IssuersDetails RPC method. */
export interface QueryIssuersDetailsResponse {
  /** issuers is a slice of registered issuers for the compliance module */
  issuers: QueryIssuersDetailsResponse_MergedIssuerDetails[];
  /** pagination defines the pagination in the response. */
  pagination?: PageResponse | undefined;
}

/**
 * MergedIssuerDetails is merged structure of iterating key and `IssuerDetails` in `entities.proto`.
 * `issuerAddress` is an iterating key, and the following items should be same with `IssuerDetails`.
 */
export interface QueryIssuersDetailsResponse_MergedIssuerDetails {
  issuerAddress: string;
  name: string;
  description: string;
  url: string;
  logo: string;
  legalEntity: string;
  creator: string;
}

/** QueryVerificationDetailsRequest is request type for the Query/VerificationDetails RPC method. */
export interface QueryVerificationDetailsRequest {
  verificationID: string;
}

/** QueryVerificationDetailsResponse is response type for the Query/VerificationDetails RPC method. */
export interface QueryVerificationDetailsResponse {
  details?: VerificationDetails | undefined;
}

/** QueryVerificationDetailsRequest is request type for the Query/VerificationsDetails RPC method. */
export interface QueryVerificationsDetailsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryVerificationsDetailsResponse is response type for the Query/VerificationsDetails RPC method. */
export interface QueryVerificationsDetailsResponse {
  /** verifications is a slice of registered verifications for the compliance module */
  verifications: QueryVerificationsDetailsResponse_MergedVerificationDetails[];
  /** pagination defines the pagination in the response. */
  pagination?: PageResponse | undefined;
}

/**
 * MergedVerificationDetails is merged structure of iterating key and `VerificationDetails` in `entities.proto`.
 * `verification_type` and `verification_id` are iterating keys, and the following items should be same with `VerificationDetails`.
 */
export interface QueryVerificationsDetailsResponse_MergedVerificationDetails {
  verificationType: VerificationType;
  verificationID: Uint8Array;
  issuerAddress: string;
  originChain: string;
  issuanceTimestamp: number;
  expirationTimestamp: number;
  originalData: Uint8Array;
  schema: string;
  issuerVerificationId: string;
  version: number;
  isRevoked: boolean;
}

export interface QueryIssuanceTreeRootRequest {
}

export interface QueryIssuanceTreeRootResponse {
  root: Uint8Array;
}

export interface QueryRevocationTreeRootRequest {
}

export interface QueryRevocationTreeRootResponse {
  root: Uint8Array;
}

export interface QueryIssuanceProofRequest {
  credentialHash: Uint8Array;
}

export interface QueryIssuanceProofResponse {
  encodedProof: Uint8Array;
}

export interface QueryRevocationProofRequest {
  credentialHash: Uint8Array;
}

export interface QueryRevocationProofResponse {
  encodedProof: Uint8Array;
}

export interface QueryAttachedHolderPublicKeyRequest {
  address: string;
}

export interface QueryAttachedHolderPublicKeyResponse {
  pubKey: Uint8Array;
}

export interface QueryIsCredentialInZKSDIRequest {
  address: string;
  verificationID: Uint8Array;
}

export interface QueryIsCredentialInZKSDIResponse {
  included: boolean;
}

export interface QueryCredentialHashRequest {
  verificationId: Uint8Array;
}

export interface QueryCredentialHashResponse {
  credentialHash: Uint8Array;
}

export interface QueryHolderByVerificationIdRequest {
  verificationId: string;
}

export interface QueryHolderByVerificationIdResponse {
  address: string;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest = {
  encode(_: QueryParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse = {
  encode(message: QueryParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryOperatorDetailsRequest(): QueryOperatorDetailsRequest {
  return { operatorAddress: "" };
}

export const QueryOperatorDetailsRequest = {
  encode(message: QueryOperatorDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOperatorDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorDetailsRequest {
    return { operatorAddress: isSet(object.operatorAddress) ? globalThis.String(object.operatorAddress) : "" };
  },

  toJSON(message: QueryOperatorDetailsRequest): unknown {
    const obj: any = {};
    if (message.operatorAddress !== "") {
      obj.operatorAddress = message.operatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorDetailsRequest>, I>>(base?: I): QueryOperatorDetailsRequest {
    return QueryOperatorDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorDetailsRequest>, I>>(object: I): QueryOperatorDetailsRequest {
    const message = createBaseQueryOperatorDetailsRequest();
    message.operatorAddress = object.operatorAddress ?? "";
    return message;
  },
};

function createBaseQueryOperatorDetailsResponse(): QueryOperatorDetailsResponse {
  return { details: undefined };
}

export const QueryOperatorDetailsResponse = {
  encode(message: QueryOperatorDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      OperatorDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOperatorDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOperatorDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = OperatorDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOperatorDetailsResponse {
    return { details: isSet(object.details) ? OperatorDetails.fromJSON(object.details) : undefined };
  },

  toJSON(message: QueryOperatorDetailsResponse): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = OperatorDetails.toJSON(message.details);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOperatorDetailsResponse>, I>>(base?: I): QueryOperatorDetailsResponse {
    return QueryOperatorDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOperatorDetailsResponse>, I>>(object: I): QueryOperatorDetailsResponse {
    const message = createBaseQueryOperatorDetailsResponse();
    message.details = (object.details !== undefined && object.details !== null)
      ? OperatorDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseQueryAddressDetailsRequest(): QueryAddressDetailsRequest {
  return { address: "" };
}

export const QueryAddressDetailsRequest = {
  encode(message: QueryAddressDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAddressDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressDetailsRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAddressDetailsRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressDetailsRequest>, I>>(base?: I): QueryAddressDetailsRequest {
    return QueryAddressDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressDetailsRequest>, I>>(object: I): QueryAddressDetailsRequest {
    const message = createBaseQueryAddressDetailsRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryAddressDetailsResponse(): QueryAddressDetailsResponse {
  return { data: undefined };
}

export const QueryAddressDetailsResponse = {
  encode(message: QueryAddressDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      AddressDetails.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAddressDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = AddressDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressDetailsResponse {
    return { data: isSet(object.data) ? AddressDetails.fromJSON(object.data) : undefined };
  },

  toJSON(message: QueryAddressDetailsResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = AddressDetails.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressDetailsResponse>, I>>(base?: I): QueryAddressDetailsResponse {
    return QueryAddressDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressDetailsResponse>, I>>(object: I): QueryAddressDetailsResponse {
    const message = createBaseQueryAddressDetailsResponse();
    message.data = (object.data !== undefined && object.data !== null)
      ? AddressDetails.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseQueryAddressesDetailsRequest(): QueryAddressesDetailsRequest {
  return { pagination: undefined };
}

export const QueryAddressesDetailsRequest = {
  encode(message: QueryAddressesDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAddressesDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressesDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressesDetailsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAddressesDetailsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressesDetailsRequest>, I>>(base?: I): QueryAddressesDetailsRequest {
    return QueryAddressesDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressesDetailsRequest>, I>>(object: I): QueryAddressesDetailsRequest {
    const message = createBaseQueryAddressesDetailsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAddressesDetailsResponse(): QueryAddressesDetailsResponse {
  return { addresses: [], pagination: undefined };
}

export const QueryAddressesDetailsResponse = {
  encode(message: QueryAddressesDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      QueryAddressesDetailsResponse_MergedAddressDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAddressesDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressesDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(QueryAddressesDetailsResponse_MergedAddressDetails.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressesDetailsResponse {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => QueryAddressesDetailsResponse_MergedAddressDetails.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAddressesDetailsResponse): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => QueryAddressesDetailsResponse_MergedAddressDetails.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressesDetailsResponse>, I>>(base?: I): QueryAddressesDetailsResponse {
    return QueryAddressesDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressesDetailsResponse>, I>>(
    object: I,
  ): QueryAddressesDetailsResponse {
    const message = createBaseQueryAddressesDetailsResponse();
    message.addresses =
      object.addresses?.map((e) => QueryAddressesDetailsResponse_MergedAddressDetails.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAddressesDetailsResponse_MergedAddressDetails(): QueryAddressesDetailsResponse_MergedAddressDetails {
  return { address: "", isVerified: false, isRevoked: false, verifications: [] };
}

export const QueryAddressesDetailsResponse_MergedAddressDetails = {
  encode(
    message: QueryAddressesDetailsResponse_MergedAddressDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.isVerified !== false) {
      writer.uint32(16).bool(message.isVerified);
    }
    if (message.isRevoked !== false) {
      writer.uint32(24).bool(message.isRevoked);
    }
    for (const v of message.verifications) {
      Verification.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAddressesDetailsResponse_MergedAddressDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAddressesDetailsResponse_MergedAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRevoked = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verifications.push(Verification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAddressesDetailsResponse_MergedAddressDetails {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      isRevoked: isSet(object.isRevoked) ? globalThis.Boolean(object.isRevoked) : false,
      verifications: globalThis.Array.isArray(object?.verifications)
        ? object.verifications.map((e: any) => Verification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAddressesDetailsResponse_MergedAddressDetails): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.isRevoked !== false) {
      obj.isRevoked = message.isRevoked;
    }
    if (message.verifications?.length) {
      obj.verifications = message.verifications.map((e) => Verification.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAddressesDetailsResponse_MergedAddressDetails>, I>>(
    base?: I,
  ): QueryAddressesDetailsResponse_MergedAddressDetails {
    return QueryAddressesDetailsResponse_MergedAddressDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAddressesDetailsResponse_MergedAddressDetails>, I>>(
    object: I,
  ): QueryAddressesDetailsResponse_MergedAddressDetails {
    const message = createBaseQueryAddressesDetailsResponse_MergedAddressDetails();
    message.address = object.address ?? "";
    message.isVerified = object.isVerified ?? false;
    message.isRevoked = object.isRevoked ?? false;
    message.verifications = object.verifications?.map((e) => Verification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryIssuerDetailsRequest(): QueryIssuerDetailsRequest {
  return { issuerAddress: "" };
}

export const QueryIssuerDetailsRequest = {
  encode(message: QueryIssuerDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.issuerAddress !== "") {
      writer.uint32(10).string(message.issuerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuerDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuerDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuerDetailsRequest {
    return { issuerAddress: isSet(object.issuerAddress) ? globalThis.String(object.issuerAddress) : "" };
  },

  toJSON(message: QueryIssuerDetailsRequest): unknown {
    const obj: any = {};
    if (message.issuerAddress !== "") {
      obj.issuerAddress = message.issuerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuerDetailsRequest>, I>>(base?: I): QueryIssuerDetailsRequest {
    return QueryIssuerDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuerDetailsRequest>, I>>(object: I): QueryIssuerDetailsRequest {
    const message = createBaseQueryIssuerDetailsRequest();
    message.issuerAddress = object.issuerAddress ?? "";
    return message;
  },
};

function createBaseQueryIssuerDetailsResponse(): QueryIssuerDetailsResponse {
  return { details: undefined };
}

export const QueryIssuerDetailsResponse = {
  encode(message: QueryIssuerDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      IssuerDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuerDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuerDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = IssuerDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuerDetailsResponse {
    return { details: isSet(object.details) ? IssuerDetails.fromJSON(object.details) : undefined };
  },

  toJSON(message: QueryIssuerDetailsResponse): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = IssuerDetails.toJSON(message.details);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuerDetailsResponse>, I>>(base?: I): QueryIssuerDetailsResponse {
    return QueryIssuerDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuerDetailsResponse>, I>>(object: I): QueryIssuerDetailsResponse {
    const message = createBaseQueryIssuerDetailsResponse();
    message.details = (object.details !== undefined && object.details !== null)
      ? IssuerDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseQueryIssuersDetailsRequest(): QueryIssuersDetailsRequest {
  return { pagination: undefined };
}

export const QueryIssuersDetailsRequest = {
  encode(message: QueryIssuersDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuersDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuersDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuersDetailsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryIssuersDetailsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuersDetailsRequest>, I>>(base?: I): QueryIssuersDetailsRequest {
    return QueryIssuersDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuersDetailsRequest>, I>>(object: I): QueryIssuersDetailsRequest {
    const message = createBaseQueryIssuersDetailsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIssuersDetailsResponse(): QueryIssuersDetailsResponse {
  return { issuers: [], pagination: undefined };
}

export const QueryIssuersDetailsResponse = {
  encode(message: QueryIssuersDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.issuers) {
      QueryIssuersDetailsResponse_MergedIssuerDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuersDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuersDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuers.push(QueryIssuersDetailsResponse_MergedIssuerDetails.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuersDetailsResponse {
    return {
      issuers: globalThis.Array.isArray(object?.issuers)
        ? object.issuers.map((e: any) => QueryIssuersDetailsResponse_MergedIssuerDetails.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryIssuersDetailsResponse): unknown {
    const obj: any = {};
    if (message.issuers?.length) {
      obj.issuers = message.issuers.map((e) => QueryIssuersDetailsResponse_MergedIssuerDetails.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuersDetailsResponse>, I>>(base?: I): QueryIssuersDetailsResponse {
    return QueryIssuersDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuersDetailsResponse>, I>>(object: I): QueryIssuersDetailsResponse {
    const message = createBaseQueryIssuersDetailsResponse();
    message.issuers = object.issuers?.map((e) => QueryIssuersDetailsResponse_MergedIssuerDetails.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIssuersDetailsResponse_MergedIssuerDetails(): QueryIssuersDetailsResponse_MergedIssuerDetails {
  return { issuerAddress: "", name: "", description: "", url: "", logo: "", legalEntity: "", creator: "" };
}

export const QueryIssuersDetailsResponse_MergedIssuerDetails = {
  encode(
    message: QueryIssuersDetailsResponse_MergedIssuerDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.issuerAddress !== "") {
      writer.uint32(10).string(message.issuerAddress);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.logo !== "") {
      writer.uint32(42).string(message.logo);
    }
    if (message.legalEntity !== "") {
      writer.uint32(50).string(message.legalEntity);
    }
    if (message.creator !== "") {
      writer.uint32(58).string(message.creator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuersDetailsResponse_MergedIssuerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuersDetailsResponse_MergedIssuerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.legalEntity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuersDetailsResponse_MergedIssuerDetails {
    return {
      issuerAddress: isSet(object.issuerAddress) ? globalThis.String(object.issuerAddress) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      legalEntity: isSet(object.legalEntity) ? globalThis.String(object.legalEntity) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: QueryIssuersDetailsResponse_MergedIssuerDetails): unknown {
    const obj: any = {};
    if (message.issuerAddress !== "") {
      obj.issuerAddress = message.issuerAddress;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.legalEntity !== "") {
      obj.legalEntity = message.legalEntity;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuersDetailsResponse_MergedIssuerDetails>, I>>(
    base?: I,
  ): QueryIssuersDetailsResponse_MergedIssuerDetails {
    return QueryIssuersDetailsResponse_MergedIssuerDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuersDetailsResponse_MergedIssuerDetails>, I>>(
    object: I,
  ): QueryIssuersDetailsResponse_MergedIssuerDetails {
    const message = createBaseQueryIssuersDetailsResponse_MergedIssuerDetails();
    message.issuerAddress = object.issuerAddress ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.url = object.url ?? "";
    message.logo = object.logo ?? "";
    message.legalEntity = object.legalEntity ?? "";
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseQueryVerificationDetailsRequest(): QueryVerificationDetailsRequest {
  return { verificationID: "" };
}

export const QueryVerificationDetailsRequest = {
  encode(message: QueryVerificationDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.verificationID !== "") {
      writer.uint32(10).string(message.verificationID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerificationDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.verificationID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationDetailsRequest {
    return { verificationID: isSet(object.verificationID) ? globalThis.String(object.verificationID) : "" };
  },

  toJSON(message: QueryVerificationDetailsRequest): unknown {
    const obj: any = {};
    if (message.verificationID !== "") {
      obj.verificationID = message.verificationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVerificationDetailsRequest>, I>>(base?: I): QueryVerificationDetailsRequest {
    return QueryVerificationDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVerificationDetailsRequest>, I>>(
    object: I,
  ): QueryVerificationDetailsRequest {
    const message = createBaseQueryVerificationDetailsRequest();
    message.verificationID = object.verificationID ?? "";
    return message;
  },
};

function createBaseQueryVerificationDetailsResponse(): QueryVerificationDetailsResponse {
  return { details: undefined };
}

export const QueryVerificationDetailsResponse = {
  encode(message: QueryVerificationDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      VerificationDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerificationDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = VerificationDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationDetailsResponse {
    return { details: isSet(object.details) ? VerificationDetails.fromJSON(object.details) : undefined };
  },

  toJSON(message: QueryVerificationDetailsResponse): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = VerificationDetails.toJSON(message.details);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVerificationDetailsResponse>, I>>(
    base?: I,
  ): QueryVerificationDetailsResponse {
    return QueryVerificationDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVerificationDetailsResponse>, I>>(
    object: I,
  ): QueryVerificationDetailsResponse {
    const message = createBaseQueryVerificationDetailsResponse();
    message.details = (object.details !== undefined && object.details !== null)
      ? VerificationDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseQueryVerificationsDetailsRequest(): QueryVerificationsDetailsRequest {
  return { pagination: undefined };
}

export const QueryVerificationsDetailsRequest = {
  encode(message: QueryVerificationsDetailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerificationsDetailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationsDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationsDetailsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryVerificationsDetailsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVerificationsDetailsRequest>, I>>(
    base?: I,
  ): QueryVerificationsDetailsRequest {
    return QueryVerificationsDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVerificationsDetailsRequest>, I>>(
    object: I,
  ): QueryVerificationsDetailsRequest {
    const message = createBaseQueryVerificationsDetailsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryVerificationsDetailsResponse(): QueryVerificationsDetailsResponse {
  return { verifications: [], pagination: undefined };
}

export const QueryVerificationsDetailsResponse = {
  encode(message: QueryVerificationsDetailsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.verifications) {
      QueryVerificationsDetailsResponse_MergedVerificationDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerificationsDetailsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationsDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.verifications.push(
            QueryVerificationsDetailsResponse_MergedVerificationDetails.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationsDetailsResponse {
    return {
      verifications: globalThis.Array.isArray(object?.verifications)
        ? object.verifications.map((e: any) => QueryVerificationsDetailsResponse_MergedVerificationDetails.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryVerificationsDetailsResponse): unknown {
    const obj: any = {};
    if (message.verifications?.length) {
      obj.verifications = message.verifications.map((e) =>
        QueryVerificationsDetailsResponse_MergedVerificationDetails.toJSON(e)
      );
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVerificationsDetailsResponse>, I>>(
    base?: I,
  ): QueryVerificationsDetailsResponse {
    return QueryVerificationsDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVerificationsDetailsResponse>, I>>(
    object: I,
  ): QueryVerificationsDetailsResponse {
    const message = createBaseQueryVerificationsDetailsResponse();
    message.verifications =
      object.verifications?.map((e) => QueryVerificationsDetailsResponse_MergedVerificationDetails.fromPartial(e)) ||
      [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryVerificationsDetailsResponse_MergedVerificationDetails(): QueryVerificationsDetailsResponse_MergedVerificationDetails {
  return {
    verificationType: 0,
    verificationID: new Uint8Array(0),
    issuerAddress: "",
    originChain: "",
    issuanceTimestamp: 0,
    expirationTimestamp: 0,
    originalData: new Uint8Array(0),
    schema: "",
    issuerVerificationId: "",
    version: 0,
    isRevoked: false,
  };
}

export const QueryVerificationsDetailsResponse_MergedVerificationDetails = {
  encode(
    message: QueryVerificationsDetailsResponse_MergedVerificationDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.verificationType !== 0) {
      writer.uint32(8).int32(message.verificationType);
    }
    if (message.verificationID.length !== 0) {
      writer.uint32(18).bytes(message.verificationID);
    }
    if (message.issuerAddress !== "") {
      writer.uint32(26).string(message.issuerAddress);
    }
    if (message.originChain !== "") {
      writer.uint32(34).string(message.originChain);
    }
    if (message.issuanceTimestamp !== 0) {
      writer.uint32(40).uint32(message.issuanceTimestamp);
    }
    if (message.expirationTimestamp !== 0) {
      writer.uint32(48).uint32(message.expirationTimestamp);
    }
    if (message.originalData.length !== 0) {
      writer.uint32(58).bytes(message.originalData);
    }
    if (message.schema !== "") {
      writer.uint32(66).string(message.schema);
    }
    if (message.issuerVerificationId !== "") {
      writer.uint32(74).string(message.issuerVerificationId);
    }
    if (message.version !== 0) {
      writer.uint32(80).uint32(message.version);
    }
    if (message.isRevoked !== false) {
      writer.uint32(88).bool(message.isRevoked);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerificationsDetailsResponse_MergedVerificationDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationsDetailsResponse_MergedVerificationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.verificationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verificationID = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issuerAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.originChain = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.issuanceTimestamp = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.expirationTimestamp = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.originalData = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.issuerVerificationId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isRevoked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationsDetailsResponse_MergedVerificationDetails {
    return {
      verificationType: isSet(object.verificationType) ? verificationTypeFromJSON(object.verificationType) : 0,
      verificationID: isSet(object.verificationID) ? bytesFromBase64(object.verificationID) : new Uint8Array(0),
      issuerAddress: isSet(object.issuerAddress) ? globalThis.String(object.issuerAddress) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      issuanceTimestamp: isSet(object.issuanceTimestamp) ? globalThis.Number(object.issuanceTimestamp) : 0,
      expirationTimestamp: isSet(object.expirationTimestamp) ? globalThis.Number(object.expirationTimestamp) : 0,
      originalData: isSet(object.originalData) ? bytesFromBase64(object.originalData) : new Uint8Array(0),
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      issuerVerificationId: isSet(object.issuerVerificationId) ? globalThis.String(object.issuerVerificationId) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      isRevoked: isSet(object.isRevoked) ? globalThis.Boolean(object.isRevoked) : false,
    };
  },

  toJSON(message: QueryVerificationsDetailsResponse_MergedVerificationDetails): unknown {
    const obj: any = {};
    if (message.verificationType !== 0) {
      obj.verificationType = verificationTypeToJSON(message.verificationType);
    }
    if (message.verificationID.length !== 0) {
      obj.verificationID = base64FromBytes(message.verificationID);
    }
    if (message.issuerAddress !== "") {
      obj.issuerAddress = message.issuerAddress;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.issuanceTimestamp !== 0) {
      obj.issuanceTimestamp = Math.round(message.issuanceTimestamp);
    }
    if (message.expirationTimestamp !== 0) {
      obj.expirationTimestamp = Math.round(message.expirationTimestamp);
    }
    if (message.originalData.length !== 0) {
      obj.originalData = base64FromBytes(message.originalData);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.issuerVerificationId !== "") {
      obj.issuerVerificationId = message.issuerVerificationId;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.isRevoked !== false) {
      obj.isRevoked = message.isRevoked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVerificationsDetailsResponse_MergedVerificationDetails>, I>>(
    base?: I,
  ): QueryVerificationsDetailsResponse_MergedVerificationDetails {
    return QueryVerificationsDetailsResponse_MergedVerificationDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVerificationsDetailsResponse_MergedVerificationDetails>, I>>(
    object: I,
  ): QueryVerificationsDetailsResponse_MergedVerificationDetails {
    const message = createBaseQueryVerificationsDetailsResponse_MergedVerificationDetails();
    message.verificationType = object.verificationType ?? 0;
    message.verificationID = object.verificationID ?? new Uint8Array(0);
    message.issuerAddress = object.issuerAddress ?? "";
    message.originChain = object.originChain ?? "";
    message.issuanceTimestamp = object.issuanceTimestamp ?? 0;
    message.expirationTimestamp = object.expirationTimestamp ?? 0;
    message.originalData = object.originalData ?? new Uint8Array(0);
    message.schema = object.schema ?? "";
    message.issuerVerificationId = object.issuerVerificationId ?? "";
    message.version = object.version ?? 0;
    message.isRevoked = object.isRevoked ?? false;
    return message;
  },
};

function createBaseQueryIssuanceTreeRootRequest(): QueryIssuanceTreeRootRequest {
  return {};
}

export const QueryIssuanceTreeRootRequest = {
  encode(_: QueryIssuanceTreeRootRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuanceTreeRootRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuanceTreeRootRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryIssuanceTreeRootRequest {
    return {};
  },

  toJSON(_: QueryIssuanceTreeRootRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuanceTreeRootRequest>, I>>(base?: I): QueryIssuanceTreeRootRequest {
    return QueryIssuanceTreeRootRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuanceTreeRootRequest>, I>>(_: I): QueryIssuanceTreeRootRequest {
    const message = createBaseQueryIssuanceTreeRootRequest();
    return message;
  },
};

function createBaseQueryIssuanceTreeRootResponse(): QueryIssuanceTreeRootResponse {
  return { root: new Uint8Array(0) };
}

export const QueryIssuanceTreeRootResponse = {
  encode(message: QueryIssuanceTreeRootResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.root.length !== 0) {
      writer.uint32(10).bytes(message.root);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuanceTreeRootResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuanceTreeRootResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.root = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuanceTreeRootResponse {
    return { root: isSet(object.root) ? bytesFromBase64(object.root) : new Uint8Array(0) };
  },

  toJSON(message: QueryIssuanceTreeRootResponse): unknown {
    const obj: any = {};
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuanceTreeRootResponse>, I>>(base?: I): QueryIssuanceTreeRootResponse {
    return QueryIssuanceTreeRootResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuanceTreeRootResponse>, I>>(
    object: I,
  ): QueryIssuanceTreeRootResponse {
    const message = createBaseQueryIssuanceTreeRootResponse();
    message.root = object.root ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryRevocationTreeRootRequest(): QueryRevocationTreeRootRequest {
  return {};
}

export const QueryRevocationTreeRootRequest = {
  encode(_: QueryRevocationTreeRootRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRevocationTreeRootRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRevocationTreeRootRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryRevocationTreeRootRequest {
    return {};
  },

  toJSON(_: QueryRevocationTreeRootRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRevocationTreeRootRequest>, I>>(base?: I): QueryRevocationTreeRootRequest {
    return QueryRevocationTreeRootRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRevocationTreeRootRequest>, I>>(_: I): QueryRevocationTreeRootRequest {
    const message = createBaseQueryRevocationTreeRootRequest();
    return message;
  },
};

function createBaseQueryRevocationTreeRootResponse(): QueryRevocationTreeRootResponse {
  return { root: new Uint8Array(0) };
}

export const QueryRevocationTreeRootResponse = {
  encode(message: QueryRevocationTreeRootResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.root.length !== 0) {
      writer.uint32(10).bytes(message.root);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRevocationTreeRootResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRevocationTreeRootResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.root = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRevocationTreeRootResponse {
    return { root: isSet(object.root) ? bytesFromBase64(object.root) : new Uint8Array(0) };
  },

  toJSON(message: QueryRevocationTreeRootResponse): unknown {
    const obj: any = {};
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRevocationTreeRootResponse>, I>>(base?: I): QueryRevocationTreeRootResponse {
    return QueryRevocationTreeRootResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRevocationTreeRootResponse>, I>>(
    object: I,
  ): QueryRevocationTreeRootResponse {
    const message = createBaseQueryRevocationTreeRootResponse();
    message.root = object.root ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryIssuanceProofRequest(): QueryIssuanceProofRequest {
  return { credentialHash: new Uint8Array(0) };
}

export const QueryIssuanceProofRequest = {
  encode(message: QueryIssuanceProofRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.credentialHash.length !== 0) {
      writer.uint32(10).bytes(message.credentialHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuanceProofRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuanceProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.credentialHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuanceProofRequest {
    return {
      credentialHash: isSet(object.credentialHash) ? bytesFromBase64(object.credentialHash) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryIssuanceProofRequest): unknown {
    const obj: any = {};
    if (message.credentialHash.length !== 0) {
      obj.credentialHash = base64FromBytes(message.credentialHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuanceProofRequest>, I>>(base?: I): QueryIssuanceProofRequest {
    return QueryIssuanceProofRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuanceProofRequest>, I>>(object: I): QueryIssuanceProofRequest {
    const message = createBaseQueryIssuanceProofRequest();
    message.credentialHash = object.credentialHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryIssuanceProofResponse(): QueryIssuanceProofResponse {
  return { encodedProof: new Uint8Array(0) };
}

export const QueryIssuanceProofResponse = {
  encode(message: QueryIssuanceProofResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encodedProof.length !== 0) {
      writer.uint32(10).bytes(message.encodedProof);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIssuanceProofResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIssuanceProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encodedProof = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIssuanceProofResponse {
    return { encodedProof: isSet(object.encodedProof) ? bytesFromBase64(object.encodedProof) : new Uint8Array(0) };
  },

  toJSON(message: QueryIssuanceProofResponse): unknown {
    const obj: any = {};
    if (message.encodedProof.length !== 0) {
      obj.encodedProof = base64FromBytes(message.encodedProof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIssuanceProofResponse>, I>>(base?: I): QueryIssuanceProofResponse {
    return QueryIssuanceProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIssuanceProofResponse>, I>>(object: I): QueryIssuanceProofResponse {
    const message = createBaseQueryIssuanceProofResponse();
    message.encodedProof = object.encodedProof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryRevocationProofRequest(): QueryRevocationProofRequest {
  return { credentialHash: new Uint8Array(0) };
}

export const QueryRevocationProofRequest = {
  encode(message: QueryRevocationProofRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.credentialHash.length !== 0) {
      writer.uint32(10).bytes(message.credentialHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRevocationProofRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRevocationProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.credentialHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRevocationProofRequest {
    return {
      credentialHash: isSet(object.credentialHash) ? bytesFromBase64(object.credentialHash) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryRevocationProofRequest): unknown {
    const obj: any = {};
    if (message.credentialHash.length !== 0) {
      obj.credentialHash = base64FromBytes(message.credentialHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRevocationProofRequest>, I>>(base?: I): QueryRevocationProofRequest {
    return QueryRevocationProofRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRevocationProofRequest>, I>>(object: I): QueryRevocationProofRequest {
    const message = createBaseQueryRevocationProofRequest();
    message.credentialHash = object.credentialHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryRevocationProofResponse(): QueryRevocationProofResponse {
  return { encodedProof: new Uint8Array(0) };
}

export const QueryRevocationProofResponse = {
  encode(message: QueryRevocationProofResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encodedProof.length !== 0) {
      writer.uint32(10).bytes(message.encodedProof);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRevocationProofResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRevocationProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encodedProof = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRevocationProofResponse {
    return { encodedProof: isSet(object.encodedProof) ? bytesFromBase64(object.encodedProof) : new Uint8Array(0) };
  },

  toJSON(message: QueryRevocationProofResponse): unknown {
    const obj: any = {};
    if (message.encodedProof.length !== 0) {
      obj.encodedProof = base64FromBytes(message.encodedProof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRevocationProofResponse>, I>>(base?: I): QueryRevocationProofResponse {
    return QueryRevocationProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRevocationProofResponse>, I>>(object: I): QueryRevocationProofResponse {
    const message = createBaseQueryRevocationProofResponse();
    message.encodedProof = object.encodedProof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryAttachedHolderPublicKeyRequest(): QueryAttachedHolderPublicKeyRequest {
  return { address: "" };
}

export const QueryAttachedHolderPublicKeyRequest = {
  encode(message: QueryAttachedHolderPublicKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAttachedHolderPublicKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAttachedHolderPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAttachedHolderPublicKeyRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAttachedHolderPublicKeyRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAttachedHolderPublicKeyRequest>, I>>(
    base?: I,
  ): QueryAttachedHolderPublicKeyRequest {
    return QueryAttachedHolderPublicKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAttachedHolderPublicKeyRequest>, I>>(
    object: I,
  ): QueryAttachedHolderPublicKeyRequest {
    const message = createBaseQueryAttachedHolderPublicKeyRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryAttachedHolderPublicKeyResponse(): QueryAttachedHolderPublicKeyResponse {
  return { pubKey: new Uint8Array(0) };
}

export const QueryAttachedHolderPublicKeyResponse = {
  encode(message: QueryAttachedHolderPublicKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubKey.length !== 0) {
      writer.uint32(10).bytes(message.pubKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAttachedHolderPublicKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAttachedHolderPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAttachedHolderPublicKeyResponse {
    return { pubKey: isSet(object.pubKey) ? bytesFromBase64(object.pubKey) : new Uint8Array(0) };
  },

  toJSON(message: QueryAttachedHolderPublicKeyResponse): unknown {
    const obj: any = {};
    if (message.pubKey.length !== 0) {
      obj.pubKey = base64FromBytes(message.pubKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAttachedHolderPublicKeyResponse>, I>>(
    base?: I,
  ): QueryAttachedHolderPublicKeyResponse {
    return QueryAttachedHolderPublicKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAttachedHolderPublicKeyResponse>, I>>(
    object: I,
  ): QueryAttachedHolderPublicKeyResponse {
    const message = createBaseQueryAttachedHolderPublicKeyResponse();
    message.pubKey = object.pubKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryIsCredentialInZKSDIRequest(): QueryIsCredentialInZKSDIRequest {
  return { address: "", verificationID: new Uint8Array(0) };
}

export const QueryIsCredentialInZKSDIRequest = {
  encode(message: QueryIsCredentialInZKSDIRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.verificationID.length !== 0) {
      writer.uint32(18).bytes(message.verificationID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsCredentialInZKSDIRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsCredentialInZKSDIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verificationID = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsCredentialInZKSDIRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      verificationID: isSet(object.verificationID) ? bytesFromBase64(object.verificationID) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryIsCredentialInZKSDIRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.verificationID.length !== 0) {
      obj.verificationID = base64FromBytes(message.verificationID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsCredentialInZKSDIRequest>, I>>(base?: I): QueryIsCredentialInZKSDIRequest {
    return QueryIsCredentialInZKSDIRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsCredentialInZKSDIRequest>, I>>(
    object: I,
  ): QueryIsCredentialInZKSDIRequest {
    const message = createBaseQueryIsCredentialInZKSDIRequest();
    message.address = object.address ?? "";
    message.verificationID = object.verificationID ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryIsCredentialInZKSDIResponse(): QueryIsCredentialInZKSDIResponse {
  return { included: false };
}

export const QueryIsCredentialInZKSDIResponse = {
  encode(message: QueryIsCredentialInZKSDIResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.included !== false) {
      writer.uint32(8).bool(message.included);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsCredentialInZKSDIResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsCredentialInZKSDIResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.included = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIsCredentialInZKSDIResponse {
    return { included: isSet(object.included) ? globalThis.Boolean(object.included) : false };
  },

  toJSON(message: QueryIsCredentialInZKSDIResponse): unknown {
    const obj: any = {};
    if (message.included !== false) {
      obj.included = message.included;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIsCredentialInZKSDIResponse>, I>>(
    base?: I,
  ): QueryIsCredentialInZKSDIResponse {
    return QueryIsCredentialInZKSDIResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIsCredentialInZKSDIResponse>, I>>(
    object: I,
  ): QueryIsCredentialInZKSDIResponse {
    const message = createBaseQueryIsCredentialInZKSDIResponse();
    message.included = object.included ?? false;
    return message;
  },
};

function createBaseQueryCredentialHashRequest(): QueryCredentialHashRequest {
  return { verificationId: new Uint8Array(0) };
}

export const QueryCredentialHashRequest = {
  encode(message: QueryCredentialHashRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.verificationId.length !== 0) {
      writer.uint32(10).bytes(message.verificationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryCredentialHashRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCredentialHashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.verificationId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCredentialHashRequest {
    return {
      verificationId: isSet(object.verificationId) ? bytesFromBase64(object.verificationId) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryCredentialHashRequest): unknown {
    const obj: any = {};
    if (message.verificationId.length !== 0) {
      obj.verificationId = base64FromBytes(message.verificationId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCredentialHashRequest>, I>>(base?: I): QueryCredentialHashRequest {
    return QueryCredentialHashRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCredentialHashRequest>, I>>(object: I): QueryCredentialHashRequest {
    const message = createBaseQueryCredentialHashRequest();
    message.verificationId = object.verificationId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryCredentialHashResponse(): QueryCredentialHashResponse {
  return { credentialHash: new Uint8Array(0) };
}

export const QueryCredentialHashResponse = {
  encode(message: QueryCredentialHashResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.credentialHash.length !== 0) {
      writer.uint32(10).bytes(message.credentialHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryCredentialHashResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCredentialHashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.credentialHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCredentialHashResponse {
    return {
      credentialHash: isSet(object.credentialHash) ? bytesFromBase64(object.credentialHash) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryCredentialHashResponse): unknown {
    const obj: any = {};
    if (message.credentialHash.length !== 0) {
      obj.credentialHash = base64FromBytes(message.credentialHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCredentialHashResponse>, I>>(base?: I): QueryCredentialHashResponse {
    return QueryCredentialHashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCredentialHashResponse>, I>>(object: I): QueryCredentialHashResponse {
    const message = createBaseQueryCredentialHashResponse();
    message.credentialHash = object.credentialHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryHolderByVerificationIdRequest(): QueryHolderByVerificationIdRequest {
  return { verificationId: "" };
}

export const QueryHolderByVerificationIdRequest = {
  encode(message: QueryHolderByVerificationIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.verificationId !== "") {
      writer.uint32(10).string(message.verificationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHolderByVerificationIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHolderByVerificationIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.verificationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHolderByVerificationIdRequest {
    return { verificationId: isSet(object.verificationId) ? globalThis.String(object.verificationId) : "" };
  },

  toJSON(message: QueryHolderByVerificationIdRequest): unknown {
    const obj: any = {};
    if (message.verificationId !== "") {
      obj.verificationId = message.verificationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHolderByVerificationIdRequest>, I>>(
    base?: I,
  ): QueryHolderByVerificationIdRequest {
    return QueryHolderByVerificationIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHolderByVerificationIdRequest>, I>>(
    object: I,
  ): QueryHolderByVerificationIdRequest {
    const message = createBaseQueryHolderByVerificationIdRequest();
    message.verificationId = object.verificationId ?? "";
    return message;
  },
};

function createBaseQueryHolderByVerificationIdResponse(): QueryHolderByVerificationIdResponse {
  return { address: "" };
}

export const QueryHolderByVerificationIdResponse = {
  encode(message: QueryHolderByVerificationIdResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHolderByVerificationIdResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHolderByVerificationIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHolderByVerificationIdResponse {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryHolderByVerificationIdResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHolderByVerificationIdResponse>, I>>(
    base?: I,
  ): QueryHolderByVerificationIdResponse {
    return QueryHolderByVerificationIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHolderByVerificationIdResponse>, I>>(
    object: I,
  ): QueryHolderByVerificationIdResponse {
    const message = createBaseQueryHolderByVerificationIdResponse();
    message.address = object.address ?? "";
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  OperatorDetails(request: QueryOperatorDetailsRequest): Promise<QueryOperatorDetailsResponse>;
  AddressDetails(request: QueryAddressDetailsRequest): Promise<QueryAddressDetailsResponse>;
  AddressesDetails(request: QueryAddressesDetailsRequest): Promise<QueryAddressesDetailsResponse>;
  IssuerDetails(request: QueryIssuerDetailsRequest): Promise<QueryIssuerDetailsResponse>;
  IssuersDetails(request: QueryIssuersDetailsRequest): Promise<QueryIssuersDetailsResponse>;
  VerificationDetails(request: QueryVerificationDetailsRequest): Promise<QueryVerificationDetailsResponse>;
  VerificationsDetails(request: QueryVerificationsDetailsRequest): Promise<QueryVerificationsDetailsResponse>;
  IssuanceTreeRoot(request: QueryIssuanceTreeRootRequest): Promise<QueryIssuanceTreeRootResponse>;
  IssuanceProof(request: QueryIssuanceProofRequest): Promise<QueryIssuanceProofResponse>;
  RevocationTreeRoot(request: QueryRevocationTreeRootRequest): Promise<QueryRevocationTreeRootResponse>;
  RevocationProof(request: QueryRevocationProofRequest): Promise<QueryRevocationProofResponse>;
  AttachedHolderPublicKey(request: QueryAttachedHolderPublicKeyRequest): Promise<QueryAttachedHolderPublicKeyResponse>;
  IsSuitableForZK(request: QueryIsCredentialInZKSDIRequest): Promise<QueryIsCredentialInZKSDIResponse>;
  CredentialHash(request: QueryCredentialHashRequest): Promise<QueryCredentialHashResponse>;
  VerificationHolder(request: QueryHolderByVerificationIdRequest): Promise<QueryHolderByVerificationIdResponse>;
}

export const QueryServiceName = "swisstronik.compliance.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.OperatorDetails = this.OperatorDetails.bind(this);
    this.AddressDetails = this.AddressDetails.bind(this);
    this.AddressesDetails = this.AddressesDetails.bind(this);
    this.IssuerDetails = this.IssuerDetails.bind(this);
    this.IssuersDetails = this.IssuersDetails.bind(this);
    this.VerificationDetails = this.VerificationDetails.bind(this);
    this.VerificationsDetails = this.VerificationsDetails.bind(this);
    this.IssuanceTreeRoot = this.IssuanceTreeRoot.bind(this);
    this.IssuanceProof = this.IssuanceProof.bind(this);
    this.RevocationTreeRoot = this.RevocationTreeRoot.bind(this);
    this.RevocationProof = this.RevocationProof.bind(this);
    this.AttachedHolderPublicKey = this.AttachedHolderPublicKey.bind(this);
    this.IsSuitableForZK = this.IsSuitableForZK.bind(this);
    this.CredentialHash = this.CredentialHash.bind(this);
    this.VerificationHolder = this.VerificationHolder.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(_m0.Reader.create(data)));
  }

  OperatorDetails(request: QueryOperatorDetailsRequest): Promise<QueryOperatorDetailsResponse> {
    const data = QueryOperatorDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OperatorDetails", data);
    return promise.then((data) => QueryOperatorDetailsResponse.decode(_m0.Reader.create(data)));
  }

  AddressDetails(request: QueryAddressDetailsRequest): Promise<QueryAddressDetailsResponse> {
    const data = QueryAddressDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddressDetails", data);
    return promise.then((data) => QueryAddressDetailsResponse.decode(_m0.Reader.create(data)));
  }

  AddressesDetails(request: QueryAddressesDetailsRequest): Promise<QueryAddressesDetailsResponse> {
    const data = QueryAddressesDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddressesDetails", data);
    return promise.then((data) => QueryAddressesDetailsResponse.decode(_m0.Reader.create(data)));
  }

  IssuerDetails(request: QueryIssuerDetailsRequest): Promise<QueryIssuerDetailsResponse> {
    const data = QueryIssuerDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IssuerDetails", data);
    return promise.then((data) => QueryIssuerDetailsResponse.decode(_m0.Reader.create(data)));
  }

  IssuersDetails(request: QueryIssuersDetailsRequest): Promise<QueryIssuersDetailsResponse> {
    const data = QueryIssuersDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IssuersDetails", data);
    return promise.then((data) => QueryIssuersDetailsResponse.decode(_m0.Reader.create(data)));
  }

  VerificationDetails(request: QueryVerificationDetailsRequest): Promise<QueryVerificationDetailsResponse> {
    const data = QueryVerificationDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerificationDetails", data);
    return promise.then((data) => QueryVerificationDetailsResponse.decode(_m0.Reader.create(data)));
  }

  VerificationsDetails(request: QueryVerificationsDetailsRequest): Promise<QueryVerificationsDetailsResponse> {
    const data = QueryVerificationsDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerificationsDetails", data);
    return promise.then((data) => QueryVerificationsDetailsResponse.decode(_m0.Reader.create(data)));
  }

  IssuanceTreeRoot(request: QueryIssuanceTreeRootRequest): Promise<QueryIssuanceTreeRootResponse> {
    const data = QueryIssuanceTreeRootRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IssuanceTreeRoot", data);
    return promise.then((data) => QueryIssuanceTreeRootResponse.decode(_m0.Reader.create(data)));
  }

  IssuanceProof(request: QueryIssuanceProofRequest): Promise<QueryIssuanceProofResponse> {
    const data = QueryIssuanceProofRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IssuanceProof", data);
    return promise.then((data) => QueryIssuanceProofResponse.decode(_m0.Reader.create(data)));
  }

  RevocationTreeRoot(request: QueryRevocationTreeRootRequest): Promise<QueryRevocationTreeRootResponse> {
    const data = QueryRevocationTreeRootRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevocationTreeRoot", data);
    return promise.then((data) => QueryRevocationTreeRootResponse.decode(_m0.Reader.create(data)));
  }

  RevocationProof(request: QueryRevocationProofRequest): Promise<QueryRevocationProofResponse> {
    const data = QueryRevocationProofRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevocationProof", data);
    return promise.then((data) => QueryRevocationProofResponse.decode(_m0.Reader.create(data)));
  }

  AttachedHolderPublicKey(request: QueryAttachedHolderPublicKeyRequest): Promise<QueryAttachedHolderPublicKeyResponse> {
    const data = QueryAttachedHolderPublicKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AttachedHolderPublicKey", data);
    return promise.then((data) => QueryAttachedHolderPublicKeyResponse.decode(_m0.Reader.create(data)));
  }

  IsSuitableForZK(request: QueryIsCredentialInZKSDIRequest): Promise<QueryIsCredentialInZKSDIResponse> {
    const data = QueryIsCredentialInZKSDIRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsSuitableForZK", data);
    return promise.then((data) => QueryIsCredentialInZKSDIResponse.decode(_m0.Reader.create(data)));
  }

  CredentialHash(request: QueryCredentialHashRequest): Promise<QueryCredentialHashResponse> {
    const data = QueryCredentialHashRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CredentialHash", data);
    return promise.then((data) => QueryCredentialHashResponse.decode(_m0.Reader.create(data)));
  }

  VerificationHolder(request: QueryHolderByVerificationIdRequest): Promise<QueryHolderByVerificationIdResponse> {
    const data = QueryHolderByVerificationIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerificationHolder", data);
    return promise.then((data) => QueryHolderByVerificationIdResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
