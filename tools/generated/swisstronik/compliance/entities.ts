// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.28.0
// source: swisstronik/compliance/entities.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "swisstronik.compliance";

export enum VerificationType {
  /** VT_UNSPECIFIED - VT_UNSPECIFIED defines an invalid/undefined verification type. */
  VT_UNSPECIFIED = 0,
  /** VT_KYC - Know Your Custom */
  VT_KYC = 1,
  /** VT_KYB - Know Your Business */
  VT_KYB = 2,
  /** VT_KYW - Know Your Wallet */
  VT_KYW = 3,
  /** VT_HUMANITY - Check humanity */
  VT_HUMANITY = 4,
  /** VT_AML - Anti Money Laundering (check transactions) */
  VT_AML = 5,
  VT_ADDRESS = 6,
  VT_CUSTOM = 7,
  VT_CREDIT_SCORE = 8,
  /** VT_BIOMETRIC - Biometric Passports and other types of biometric verification */
  VT_BIOMETRIC = 9,
  UNRECOGNIZED = -1,
}

export function verificationTypeFromJSON(object: any): VerificationType {
  switch (object) {
    case 0:
    case "VT_UNSPECIFIED":
      return VerificationType.VT_UNSPECIFIED;
    case 1:
    case "VT_KYC":
      return VerificationType.VT_KYC;
    case 2:
    case "VT_KYB":
      return VerificationType.VT_KYB;
    case 3:
    case "VT_KYW":
      return VerificationType.VT_KYW;
    case 4:
    case "VT_HUMANITY":
      return VerificationType.VT_HUMANITY;
    case 5:
    case "VT_AML":
      return VerificationType.VT_AML;
    case 6:
    case "VT_ADDRESS":
      return VerificationType.VT_ADDRESS;
    case 7:
    case "VT_CUSTOM":
      return VerificationType.VT_CUSTOM;
    case 8:
    case "VT_CREDIT_SCORE":
      return VerificationType.VT_CREDIT_SCORE;
    case 9:
    case "VT_BIOMETRIC":
      return VerificationType.VT_BIOMETRIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerificationType.UNRECOGNIZED;
  }
}

export function verificationTypeToJSON(object: VerificationType): string {
  switch (object) {
    case VerificationType.VT_UNSPECIFIED:
      return "VT_UNSPECIFIED";
    case VerificationType.VT_KYC:
      return "VT_KYC";
    case VerificationType.VT_KYB:
      return "VT_KYB";
    case VerificationType.VT_KYW:
      return "VT_KYW";
    case VerificationType.VT_HUMANITY:
      return "VT_HUMANITY";
    case VerificationType.VT_AML:
      return "VT_AML";
    case VerificationType.VT_ADDRESS:
      return "VT_ADDRESS";
    case VerificationType.VT_CUSTOM:
      return "VT_CUSTOM";
    case VerificationType.VT_CREDIT_SCORE:
      return "VT_CREDIT_SCORE";
    case VerificationType.VT_BIOMETRIC:
      return "VT_BIOMETRIC";
    case VerificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OperatorType {
  /** OT_UNSPECIFIED - OT_UNSPECIFIED defines an invalid/undefined operator type. */
  OT_UNSPECIFIED = 0,
  /**
   * OT_INITIAL - Initial Operator, can't be removed from the list of operators.
   * Both initial (constant) and regular operators can add or remove regular operators.
   */
  OT_INITIAL = 1,
  OT_REGULAR = 2,
  UNRECOGNIZED = -1,
}

export function operatorTypeFromJSON(object: any): OperatorType {
  switch (object) {
    case 0:
    case "OT_UNSPECIFIED":
      return OperatorType.OT_UNSPECIFIED;
    case 1:
    case "OT_INITIAL":
      return OperatorType.OT_INITIAL;
    case 2:
    case "OT_REGULAR":
      return OperatorType.OT_REGULAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperatorType.UNRECOGNIZED;
  }
}

export function operatorTypeToJSON(object: OperatorType): string {
  switch (object) {
    case OperatorType.OT_UNSPECIFIED:
      return "OT_UNSPECIFIED";
    case OperatorType.OT_INITIAL:
      return "OT_INITIAL";
    case OperatorType.OT_REGULAR:
      return "OT_REGULAR";
    case OperatorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperatorDetails {
  /** Operator address, who can add / update / remove issuers */
  operator: string;
  /** Operator type */
  operatorType: OperatorType;
}

export interface IssuerDetails {
  /**
   * Allows to easily understand
   * what entity can be associated with issuer address.
   * Issuer name
   */
  name: string;
  /** Basic issuer description */
  description: string;
  /** URL to issuer website */
  url: string;
  /** URL to issuer logo */
  logo: string;
  /** Legal entity name */
  legalEntity: string;
  /** Issuer creator who created current issuer */
  creator: string;
}

export interface AddressDetails {
  /**
   * Marks if contract deployed under this address is verified
   * by community. Only verified contracts will be allowed to write
   * to x/compliance module.
   */
  isVerified: boolean;
  /** Marks if verification for this address was revoked. */
  isRevoked: boolean;
  /** Verifications passed by this address */
  verifications: Verification[];
}

export interface Verification {
  /** Contains information about verification type (KYC, proof-of-humanity, etc). */
  type: VerificationType;
  /** Contains ID of details of passed verification in storage. */
  verificationId: Uint8Array;
  /** Issuer of verification */
  issuerAddress: string;
}

/**
 * VerificationDetails must have same members with VerificationDetails in "proto/swisstronik/compliance/entities.proto"
 * But the member types can be different, such as string(address) to bytes
 */
export interface VerificationDetails {
  /** Verification type */
  type: VerificationType;
  /** Verification issuer address */
  issuerAddress: string;
  /** From which chain proof was transferred */
  originChain: string;
  /** Original issuance timestamp */
  issuanceTimestamp: number;
  /** Original expiration timestamp */
  expirationTimestamp: number;
  /** Original proof data (ZK-proof) */
  originalData: Uint8Array;
  /** ZK-proof original schema */
  schema: string;
  /** Verification id for checking(KYC/KYB/AML etc) from issuer side */
  issuerVerificationId: string;
  /** Version */
  version: number;
  /** Is revoked */
  isRevoked: boolean;
}

/** ZKCredential contains basic information, which can be used to construct proof-of-ownership of some credential */
export interface ZKCredential {
  type: VerificationType;
  issuerAddress: Uint8Array;
  holderPublicKey: Uint8Array;
  expirationTimestamp: number;
  issuanceTimestamp: number;
}

function createBaseOperatorDetails(): OperatorDetails {
  return { operator: "", operatorType: 0 };
}

export const OperatorDetails = {
  encode(message: OperatorDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    if (message.operatorType !== 0) {
      writer.uint32(16).int32(message.operatorType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OperatorDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operatorType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorDetails {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      operatorType: isSet(object.operatorType) ? operatorTypeFromJSON(object.operatorType) : 0,
    };
  },

  toJSON(message: OperatorDetails): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.operatorType !== 0) {
      obj.operatorType = operatorTypeToJSON(message.operatorType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperatorDetails>, I>>(base?: I): OperatorDetails {
    return OperatorDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperatorDetails>, I>>(object: I): OperatorDetails {
    const message = createBaseOperatorDetails();
    message.operator = object.operator ?? "";
    message.operatorType = object.operatorType ?? 0;
    return message;
  },
};

function createBaseIssuerDetails(): IssuerDetails {
  return { name: "", description: "", url: "", logo: "", legalEntity: "", creator: "" };
}

export const IssuerDetails = {
  encode(message: IssuerDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.logo !== "") {
      writer.uint32(34).string(message.logo);
    }
    if (message.legalEntity !== "") {
      writer.uint32(42).string(message.legalEntity);
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IssuerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssuerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.legalEntity = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssuerDetails {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      legalEntity: isSet(object.legalEntity) ? globalThis.String(object.legalEntity) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: IssuerDetails): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.legalEntity !== "") {
      obj.legalEntity = message.legalEntity;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IssuerDetails>, I>>(base?: I): IssuerDetails {
    return IssuerDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IssuerDetails>, I>>(object: I): IssuerDetails {
    const message = createBaseIssuerDetails();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.url = object.url ?? "";
    message.logo = object.logo ?? "";
    message.legalEntity = object.legalEntity ?? "";
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseAddressDetails(): AddressDetails {
  return { isVerified: false, isRevoked: false, verifications: [] };
}

export const AddressDetails = {
  encode(message: AddressDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isVerified !== false) {
      writer.uint32(8).bool(message.isVerified);
    }
    if (message.isRevoked !== false) {
      writer.uint32(16).bool(message.isRevoked);
    }
    for (const v of message.verifications) {
      Verification.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isRevoked = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.verifications.push(Verification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressDetails {
    return {
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      isRevoked: isSet(object.isRevoked) ? globalThis.Boolean(object.isRevoked) : false,
      verifications: globalThis.Array.isArray(object?.verifications)
        ? object.verifications.map((e: any) => Verification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressDetails): unknown {
    const obj: any = {};
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.isRevoked !== false) {
      obj.isRevoked = message.isRevoked;
    }
    if (message.verifications?.length) {
      obj.verifications = message.verifications.map((e) => Verification.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressDetails>, I>>(base?: I): AddressDetails {
    return AddressDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressDetails>, I>>(object: I): AddressDetails {
    const message = createBaseAddressDetails();
    message.isVerified = object.isVerified ?? false;
    message.isRevoked = object.isRevoked ?? false;
    message.verifications = object.verifications?.map((e) => Verification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVerification(): Verification {
  return { type: 0, verificationId: new Uint8Array(0), issuerAddress: "" };
}

export const Verification = {
  encode(message: Verification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.verificationId.length !== 0) {
      writer.uint32(18).bytes(message.verificationId);
    }
    if (message.issuerAddress !== "") {
      writer.uint32(26).string(message.issuerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Verification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verificationId = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issuerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Verification {
    return {
      type: isSet(object.type) ? verificationTypeFromJSON(object.type) : 0,
      verificationId: isSet(object.verificationId) ? bytesFromBase64(object.verificationId) : new Uint8Array(0),
      issuerAddress: isSet(object.issuerAddress) ? globalThis.String(object.issuerAddress) : "",
    };
  },

  toJSON(message: Verification): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = verificationTypeToJSON(message.type);
    }
    if (message.verificationId.length !== 0) {
      obj.verificationId = base64FromBytes(message.verificationId);
    }
    if (message.issuerAddress !== "") {
      obj.issuerAddress = message.issuerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Verification>, I>>(base?: I): Verification {
    return Verification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Verification>, I>>(object: I): Verification {
    const message = createBaseVerification();
    message.type = object.type ?? 0;
    message.verificationId = object.verificationId ?? new Uint8Array(0);
    message.issuerAddress = object.issuerAddress ?? "";
    return message;
  },
};

function createBaseVerificationDetails(): VerificationDetails {
  return {
    type: 0,
    issuerAddress: "",
    originChain: "",
    issuanceTimestamp: 0,
    expirationTimestamp: 0,
    originalData: new Uint8Array(0),
    schema: "",
    issuerVerificationId: "",
    version: 0,
    isRevoked: false,
  };
}

export const VerificationDetails = {
  encode(message: VerificationDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.issuerAddress !== "") {
      writer.uint32(18).string(message.issuerAddress);
    }
    if (message.originChain !== "") {
      writer.uint32(26).string(message.originChain);
    }
    if (message.issuanceTimestamp !== 0) {
      writer.uint32(32).uint32(message.issuanceTimestamp);
    }
    if (message.expirationTimestamp !== 0) {
      writer.uint32(40).uint32(message.expirationTimestamp);
    }
    if (message.originalData.length !== 0) {
      writer.uint32(50).bytes(message.originalData);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.issuerVerificationId !== "") {
      writer.uint32(66).string(message.issuerVerificationId);
    }
    if (message.version !== 0) {
      writer.uint32(72).uint32(message.version);
    }
    if (message.isRevoked !== false) {
      writer.uint32(80).bool(message.isRevoked);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VerificationDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerificationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issuerAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.originChain = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.issuanceTimestamp = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expirationTimestamp = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.originalData = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.issuerVerificationId = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isRevoked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerificationDetails {
    return {
      type: isSet(object.type) ? verificationTypeFromJSON(object.type) : 0,
      issuerAddress: isSet(object.issuerAddress) ? globalThis.String(object.issuerAddress) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      issuanceTimestamp: isSet(object.issuanceTimestamp) ? globalThis.Number(object.issuanceTimestamp) : 0,
      expirationTimestamp: isSet(object.expirationTimestamp) ? globalThis.Number(object.expirationTimestamp) : 0,
      originalData: isSet(object.originalData) ? bytesFromBase64(object.originalData) : new Uint8Array(0),
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      issuerVerificationId: isSet(object.issuerVerificationId) ? globalThis.String(object.issuerVerificationId) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      isRevoked: isSet(object.isRevoked) ? globalThis.Boolean(object.isRevoked) : false,
    };
  },

  toJSON(message: VerificationDetails): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = verificationTypeToJSON(message.type);
    }
    if (message.issuerAddress !== "") {
      obj.issuerAddress = message.issuerAddress;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.issuanceTimestamp !== 0) {
      obj.issuanceTimestamp = Math.round(message.issuanceTimestamp);
    }
    if (message.expirationTimestamp !== 0) {
      obj.expirationTimestamp = Math.round(message.expirationTimestamp);
    }
    if (message.originalData.length !== 0) {
      obj.originalData = base64FromBytes(message.originalData);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.issuerVerificationId !== "") {
      obj.issuerVerificationId = message.issuerVerificationId;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.isRevoked !== false) {
      obj.isRevoked = message.isRevoked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerificationDetails>, I>>(base?: I): VerificationDetails {
    return VerificationDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerificationDetails>, I>>(object: I): VerificationDetails {
    const message = createBaseVerificationDetails();
    message.type = object.type ?? 0;
    message.issuerAddress = object.issuerAddress ?? "";
    message.originChain = object.originChain ?? "";
    message.issuanceTimestamp = object.issuanceTimestamp ?? 0;
    message.expirationTimestamp = object.expirationTimestamp ?? 0;
    message.originalData = object.originalData ?? new Uint8Array(0);
    message.schema = object.schema ?? "";
    message.issuerVerificationId = object.issuerVerificationId ?? "";
    message.version = object.version ?? 0;
    message.isRevoked = object.isRevoked ?? false;
    return message;
  },
};

function createBaseZKCredential(): ZKCredential {
  return {
    type: 0,
    issuerAddress: new Uint8Array(0),
    holderPublicKey: new Uint8Array(0),
    expirationTimestamp: 0,
    issuanceTimestamp: 0,
  };
}

export const ZKCredential = {
  encode(message: ZKCredential, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.issuerAddress.length !== 0) {
      writer.uint32(18).bytes(message.issuerAddress);
    }
    if (message.holderPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.holderPublicKey);
    }
    if (message.expirationTimestamp !== 0) {
      writer.uint32(32).uint32(message.expirationTimestamp);
    }
    if (message.issuanceTimestamp !== 0) {
      writer.uint32(40).uint32(message.issuanceTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ZKCredential {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZKCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issuerAddress = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.holderPublicKey = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expirationTimestamp = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.issuanceTimestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZKCredential {
    return {
      type: isSet(object.type) ? verificationTypeFromJSON(object.type) : 0,
      issuerAddress: isSet(object.issuerAddress) ? bytesFromBase64(object.issuerAddress) : new Uint8Array(0),
      holderPublicKey: isSet(object.holderPublicKey) ? bytesFromBase64(object.holderPublicKey) : new Uint8Array(0),
      expirationTimestamp: isSet(object.expirationTimestamp) ? globalThis.Number(object.expirationTimestamp) : 0,
      issuanceTimestamp: isSet(object.issuanceTimestamp) ? globalThis.Number(object.issuanceTimestamp) : 0,
    };
  },

  toJSON(message: ZKCredential): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = verificationTypeToJSON(message.type);
    }
    if (message.issuerAddress.length !== 0) {
      obj.issuerAddress = base64FromBytes(message.issuerAddress);
    }
    if (message.holderPublicKey.length !== 0) {
      obj.holderPublicKey = base64FromBytes(message.holderPublicKey);
    }
    if (message.expirationTimestamp !== 0) {
      obj.expirationTimestamp = Math.round(message.expirationTimestamp);
    }
    if (message.issuanceTimestamp !== 0) {
      obj.issuanceTimestamp = Math.round(message.issuanceTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZKCredential>, I>>(base?: I): ZKCredential {
    return ZKCredential.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZKCredential>, I>>(object: I): ZKCredential {
    const message = createBaseZKCredential();
    message.type = object.type ?? 0;
    message.issuerAddress = object.issuerAddress ?? new Uint8Array(0);
    message.holderPublicKey = object.holderPublicKey ?? new Uint8Array(0);
    message.expirationTimestamp = object.expirationTimestamp ?? 0;
    message.issuanceTimestamp = object.issuanceTimestamp ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
